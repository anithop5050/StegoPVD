<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stego PVD — Batch Encode & Decode (Neon)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
    <!-- Required for reliable downloads -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <style>
        /* --- Default Theme (Dark Mode) Variables --- */
        body {
            /* Fallback colors for initial load */
            --bg-main: linear-gradient(135deg, #001f3f 0%, #000000 50%, #001f3f 100%);
            --text-color: #ccc; 
            --panel-bg: rgba(0, 0, 0, 0.85);
            --border-neon: rgba(0, 255, 0, 0.5);
            --glow-cyan: rgba(0, 255, 255, 0.3);
            --input-bg: #111;
            --input-border: #00ff00;
            --pre-bg: #000000;
            --pre-text: #00ff00;
            --title-color: #00ffff;
            --header-color: #00ff00;
            --nav-bg: rgba(0, 0, 0, 0.9);

            font-family: 'Inter', sans-serif;
            min-height: 100vh;
            overflow-x: hidden;
            color: var(--text-color); 
            background: var(--bg-main);
            position: relative;
            /* Add padding to the top of the body to clear the fixed nav bar */
            padding-top: 64px; 
        }

        /* --- Light Mode Variables --- */
        .light-mode {
            --bg-main: linear-gradient(135deg, #e0f7ff 0%, #ffffff 50%, #f0f8ff 100%);
            --text-color: #333;
            --panel-bg: rgba(255, 255, 255, 0.95);
            --border-neon: rgba(0, 150, 150, 0.5); /* Darker Teal */
            --glow-cyan: rgba(0, 100, 100, 0.2);
            --input-bg: #f8f8f8;
            --input-border: #999;
            --pre-bg: #eeeeee;
            --pre-text: #008800; /* Darker console green */
            --title-color: #0055aa;
            --header-color: #00a000;
            --nav-bg: rgba(255, 255, 255, 0.9);
        }

        /* Matrix Rain styling */
        .data-bits {
            position: absolute;
            font-size: 14px;
            color: #00ff00; 
            animation: matrixRain 12s linear infinite;
            font-weight: bold;
        }
        @keyframes matrixRain {
            0% { transform: translateY(-120vh); opacity: 1; }
            100% { transform: translateY(120vh); opacity: 0; }
        }
        /* Hide Matrix Rain in light mode */
        .light-mode #matrix { display: none; }

        /* Styling for the main content card */
        .panel {
            background: var(--panel-bg);
            backdrop-filter: blur(10px);
            border: 2px solid var(--border-neon); 
            border-radius: 15px;
            padding: 24px;
            max-width: 950px;
            width: 95%;
            box-shadow: 0 0 20px var(--glow-cyan); 
            margin: 20px auto;
        }
        .section-title {
            color: var(--title-color);
            border-bottom: 2px solid #005500;
            padding-bottom: 5px;
            margin-bottom: 15px;
            font-weight: 600;
            font-size: 1.5rem;
        }
        .light-mode .section-title {
            border-bottom-color: #ccc;
        }

        /* Styling for inputs and controls */
        input[type="file"], textarea, button {
            background: var(--input-bg);
            border: 1px solid var(--input-border);
            color: var(--text-color);
            padding: 10px;
            border-radius: 8px;
            margin-top: 8px;
            transition: all 0.2s;
            box-sizing: border-box; 
        }
        input[type="file"]:hover, textarea:hover, button:hover {
            border-color: var(--title-color); 
            box-shadow: 0 0 5px var(--title-color);
        }
        button {
            background: var(--header-color);
            color: var(--panel-bg);
            font-weight: bold;
            text-shadow: none;
            padding: 12px 15px;
        }
        button:hover {
            background: #00ffff;
        }
        textarea[readonly] {
            opacity: 0.7;
        }
        pre {
            background: var(--pre-bg);
            border: 1px solid #005500;
            color: var(--pre-text);
            padding: 10px;
            margin-top: 15px;
            border-radius: 8px;
            font-family: monospace;
            white-space: pre-wrap;
            overflow: auto;
            min-height: 150px;
        }
        .row { display: flex; gap: 24px; flex-wrap: wrap; }
        .col { flex: 1; min-width: 300px; }
        /* Image preview styling */
        img { max-width: 100%; display: block; margin-top: 8px; border-radius: 4px; border: 1px solid #005500; }
        
        /* Apply thematic colors to text classes */
        .text-green-500 { color: var(--header-color); }
        .text-cyan-400 { color: var(--title-color); }
        .text-green-400 { color: var(--header-color); }
        .text-xs { color: var(--text-color); }

        /* Specific style for the utility clear button */
        .utility-btn {
            background: #666;
            color: #fff;
            padding: 8px 12px;
            font-size: 0.8rem;
        }
        .utility-btn:hover {
            background: #888;
            box-shadow: none;
        }
        /* Navigation Bar Styles */
        .navbar {
            background: var(--nav-bg);
            backdrop-filter: blur(8px);
            border-bottom: 1px solid var(--border-neon);
            box-shadow: 0 2px 10px var(--glow-cyan);
            z-index: 100;
        }
        .nav-link {
            color: var(--text-color);
            transition: color 0.3s, box-shadow 0.3s;
            padding-bottom: 4px; /* Ensure space for border */
        }
        .nav-link:hover {
            color: var(--header-color);
            text-shadow: 0 0 5px var(--header-color);
        }
        /* ACTIVE LINK STYLES (MATCHING ANIMATION) */
        .nav-link.active {
            color: var(--title-color);
            font-weight: bold;
            border-bottom: 2px solid var(--title-color);
            /* Add glow animation for active link */
            animation: activeGlow 1.5s infinite alternate;
        }
        @keyframes activeGlow {
            0% {
                text-shadow: 0 0 5px var(--title-color), 0 0 10px var(--title-color);
            }
            100% {
                text-shadow: 0 0 10px var(--title-color), 0 0 20px var(--title-color);
            }
        }
    </style>
</head>
<body class="tech-bg">
    <!-- Matrix Rain Effect -->
    <div id="matrix" class="fixed inset-0 pointer-events-none"></div>

    <!-- Navigation Bar -->
    <nav class="navbar fixed top-0 left-0 right-0 h-16 flex items-center justify-between px-4 sm:px-8">
        <div class="text-xl font-bold text-green-500">
            Stego <span class="text-cyan-400">PVD</span>
        </div>
        <div class="flex items-center space-x-6">
            <a href="{{ url_for('home') }}" class="nav-link">Home</a>
            <a href="{{ url_for('detection_page') }}" class="nav-link">Detection</a>
            
            <!-- Theme Toggle Button (moved to the end of the nav bar) -->
            <button id="theme-toggle" title="Toggle Theme" class="p-2 rounded-full text-white bg-gray-700 hover:bg-gray-600 transition duration-300">
                <svg id="moon-icon" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />
                </svg>
                <svg id="sun-icon" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.354 5.354l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />
                </svg>
            </button>
        </div>
    </nav>

    <section class="py-10 relative z-10">
        <!-- The theme toggle button was moved into the nav bar -->
        <div class="panel">
            <h1 class="text-3xl md:text-4xl font-bold text-center mb-8 text-green-500">
                PVD Batch Processor
            </h1>
            <h2 class="text-xl font-semibold text-center mb-6 text-cyan-400">
                Stego PVD — Batch Encode & Single Decode
            </h2>

            <div class="row">
                <!-- ENCODE COLUMN -->
                <div class="col">
                    <h3 class="section-title">1. Embed Message (Single Image)</h3>
                    
                    <label class="block text-sm font-medium mb-1 text-cyan-400">Load image (select one)</label>
                    <input id="inFile" type="file" accept="image/*" class="w-full"> 
                    <img id="preview" alt="Image preview area" style="display:none;">
                    
                    <label class="block text-sm font-medium mt-4 mb-1 text-cyan-400">Message to hide</label>
                    <textarea id="message" rows="3" placeholder="Enter message to hide in ALL selected files" class="w-full"></textarea>
                    
                    <button id="encodeBtn" class="w-full">Encode ALL Selected Images (PVD R-Channel)</button>

                    <p class="text-xs mt-3 text-green-400">
                        *Files download automatically. RAW .bin is the safest for decoding.
                    </p>
                </div>

                <!-- DECODE COLUMN -->
                <div class="col">
                    <h3 class="section-title">2. Extract Message (Single File)</h3>
                    
                    <label class="block text-sm font-medium mb-1 text-cyan-400">Upload RAW .bin (Recommended)</label>
                    <input id="binIn" type="file" accept=".bin,application/octet-stream" class="w-full">
                    
                    <label class="block text-sm font-medium mt-4 mb-1 text-cyan-400">OR upload image (BMP/PNG)</label>
                    <input id="imgIn" type="file" accept="image/*" class="w-full">
                    
                    <button id="decodeBtn" class="w-full">Decode (from uploaded file)</button>
                    
                    <label class="block text-sm font-medium mt-4 mb-1 text-cyan-400">Decoded Message</label>
                    <textarea id="decoded" rows="4" readonly placeholder="Decoded message appears here..." class="w-full"></textarea>

                    <!-- NEW CLEAR CACHE BUTTON -->
                    <button class="utility-btn w-full mt-4" onclick="clearCacheAndReload()">Clear Cache & Reset Theme</button>
                </div>
            </div>

            <h3 class="section-title mt-8">Processing Log</h3>
            <pre id="log">No actions yet.</pre>
        </div>
    </section>

    <canvas id="canvas" style="display:none;"></canvas>

    <script>
        // --- Setup and Constants (Matching previous working version) ---
        
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        const inFile = document.getElementById('inFile');
        const preview = document.getElementById('preview');
        const messageEl = document.getElementById('message');
        const encodeBtn = document.getElementById('encodeBtn');
        
        const binIn = document.getElementById('binIn');
        const imgIn = document.getElementById('imgIn');
        const decodeBtn = document.getElementById('decodeBtn');
        const decodedEl = document.getElementById('decoded');
        const log = document.getElementById('log');
        const toggleButton = document.getElementById('theme-toggle');

        let selectedFiles = []; 
        
        // PVD Constants
        const PVD_RANGES = [[0, 7, 3], [8, 15, 3], [16, 31, 4], [32, 63, 5], [64, 127, 6], [128, 255, 7]];
        const HEADER_SIZE_BITS = 32;
        const DOWNLOAD_DELAY_MS = 500; 

        // Helper Functions (PVD, Text/Bit Conversion, Download, etc.)
        function logMessage(msg) { log.textContent = `[${new Date().toLocaleTimeString()}] ${msg}\n${log.textContent}`; }
        const delay = ms => new Promise(resolve => setTimeout(resolve, ms));
        
        function getPVDRange(diff) {
            for (const [L, U, t] of PVD_RANGES) { if (diff >= L && diff <= U) { return { L, U, t }; } }
            return null;
        }
        function textToBytes(s){ return Array.from(s).map(c => c.charCodeAt(0)); }
        function bytesToText(arr){ return String.fromCharCode(...arr); }
        function messageToBits(message) {
            const msgBytes = textToBytes(message);
            const len = msgBytes.length;
            const lenBytes = [(len>>24)&0xFF,(len>>16)&0xFF,(len>>8)&0xFF,len&0xFF];
            let bits = '';
            for(const b of lenBytes) bits += b.toString(2).padStart(8,'0');
            for(const b of msgBytes) bits += b.toString(2).padStart(8,'0');
            return { bits, len };
        }
        function bitsToBytes(msgBits){
            const bytes=[];
            for(let i=0;i<msgBits.length;i+=8){ 
                const charCode = parseInt(msgBits.slice(i,i+8),2);
                if (isNaN(charCode)) continue; 
                bytes.push(charCode);
            }
            return bytes;
        }

        function triggerDownload(blob, fileName) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        // ----------------------------------------------------------------------
        // FILE INPUT HANDLER (Updated for Single File selection)
        // ----------------------------------------------------------------------
        inFile.addEventListener('change', e=>{
            // Since 'multiple' is removed, e.target.files will contain 0 or 1 file.
            selectedFiles = Array.from(e.target.files);
            if (selectedFiles.length > 0) {
                // Update message for single file
                logMessage(`Selected 1 image: ${selectedFiles[0].name}. Enter message and click 'Encode ALL'.`);
                const r = new FileReader();
                r.onload = ev => { 
                    preview.src = ev.target.result; 
                    preview.style.display = 'block'; // Show preview
                };
                r.readAsDataURL(selectedFiles[0]);
            } else {
                logMessage('No file selected.');
                preview.src = '';
                preview.style.display = 'none'; // Hide preview to fix broken icon
            }
        });

        // ----------------------------------------------------------------------
        // CORE ENCODER FUNCTION
        // ----------------------------------------------------------------------
        function encodeAndDownloadSingleImage(file, msgBytes, len, fileIndex) {
            return new Promise((resolve, reject) => {
                const r = new FileReader();
                r.onload = (ev) => {
                    const img = new Image();
                    img.onload = () => {
                        const fileNameBase = file.name.split('.').slice(0, -1).join('_');
                        
                        canvas.width = img.width;
                        canvas.height = img.height;
                        ctx.drawImage(img, 0, 0);
                        let currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        const data = new Uint8ClampedArray(currentImageData.data);

                        const { bits, len: msgLen } = messageToBits(messageEl.value);
                        const totalMessageBits = bits.length;
                        
                        let bi=0; 
                        let pairsUsed = 0;
                        
                        // Check capacity early to skip bad files
                        let maxCapacity = 0;
                        for(let i=0; i < data.length; i += 8){
                            const range = getPVDRange(Math.abs(data[i+4] - data[i]));
                            if(range) maxCapacity += range.t;
                        }
                        if (totalMessageBits > maxCapacity) {
                            logMessage(`[${fileIndex + 1}/${selectedFiles.length}] ERROR: Message (${totalMessageBits} bits) is too big for ${file.name} (${maxCapacity} bits max). Skipping file.`);
                            return resolve();
                        }
                        
                        // PVD Embedding loop
                        for(let i=0; i < data.length; i += 8){
                            if(bi >= totalMessageBits) break;
                            const p1_idx = i;
                            const p2_idx = i + 4;
                            if(p2_idx >= data.length) break;

                            let p1 = data[p1_idx];
                            let p2 = data[p2_idx];
                            const diff = Math.abs(p2 - p1);
                            const sign = (p2 >= p1) ? 1 : -1;
                            const range = getPVDRange(diff);

                            if(range){
                                const t = range.t;
                                const remainingMessageBits = totalMessageBits - bi;
                                const actualBitsToTake = Math.min(t, remainingMessageBits);
                                
                                if (actualBitsToTake === 0) break;
                                
                                const bitsToHide = bits.substring(bi, bi + actualBitsToTake);
                                const paddedBits = bitsToHide.padEnd(t, '0');
                                
                                const b = parseInt(paddedBits, 2);
                                bi += actualBitsToTake; 
                                
                                const d_prime = range.L + b;
                                const delta = d_prime - diff;
                                
                                let p1_prime, p2_prime;
                                if (sign === 1) { 
                                    p1_prime = p1 - Math.floor(delta / 2);
                                    p2_prime = p2 + Math.ceil(delta / 2);
                                } else { 
                                    p1_prime = p1 + Math.ceil(delta / 2);
                                    p2_prime = p2 - Math.floor(delta / 2);
                                }

                                p1_prime = Math.max(0, Math.min(255, p1_prime));
                                p2_prime = Math.max(0, Math.min(255, p2_prime));

                                data[p1_idx] = p1_prime;
                                data[p2_idx] = p2_prime;
                                pairsUsed++;
                            }
                        }

                        // 3. Prepare and trigger individual downloads
                        const header = new ArrayBuffer(8);
                        const dv = new DataView(header);
                        dv.setUint32(0, img.width, true);
                        dv.setUint32(4, img.height, true);
                        const pixelBytes = new Uint8Array(data.buffer.slice(0));
                        const outBuffer = new Uint8Array(8 + pixelBytes.length);
                        outBuffer.set(new Uint8Array(header), 0);
                        outBuffer.set(pixelBytes, 8);
                        const blobBin = new Blob([outBuffer], {type:'application/octet-stream'});
                        
                        // BMP download
                        const bmpBlob = generateBMPFromRGBA(data, img.width, img.height);
                        
                        // Trigger downloads (will execute after promise resolve)
                        resolve({ 
                            bin: blobBin, 
                            bmp: bmpBlob, 
                            name: fileNameBase, 
                            pairs: pairsUsed 
                        });
                    };
                    img.src = ev.target.result;
                };
                r.readAsDataURL(file);
            });
        }

        // ----------------------------------------------------------------------
        // BATCH ENCODE HANDLER
        // ----------------------------------------------------------------------
        encodeBtn.addEventListener('click', async ()=>{
            if(selectedFiles.length === 0) return alert('Load one or more images first.');
            if(!messageEl.value) return alert('Enter a message.');
            
            encodeBtn.disabled = true;
            log.textContent = `Starting batch encoding for ${selectedFiles.length} files... Please wait.`;

            for (let i = 0; i < selectedFiles.length; i++) {
                const file = selectedFiles[i];
                log.textContent += `\n--- Processing file ${i + 1} of ${selectedFiles.length}: ${file.name} ---`;
                
                try {
                    const downloadData = await encodeAndDownloadSingleImage(file, textToBytes(messageEl.value), messageEl.value.length, i);
                    if (downloadData) {
                        triggerDownload(downloadData.bin, `${downloadData.name}_stego.bin`);
                        triggerDownload(downloadData.bmp, `${downloadData.name}_stego.bmp`);
                        logMessage(`SUCCESS: Encoded '${file.name}'. Pairs used: ${downloadData.pairs}. Downloaded .bin and .bmp.`);
                    }
                    // CRITICAL FIX: Delay after successful download pair
                    await delay(DOWNLOAD_DELAY_MS);
                } catch (error) {
                    logMessage(`CRITICAL ERROR processing ${file.name}: ${error.message}`);
                }
            }
            
            encodeBtn.disabled = false;
            logMessage('\n✅ Batch encoding complete. Check your downloads folder.');
        });

        // ----------------------------------------------------------------------
        // DECODING LOGIC (Using original pasted flow)
        // ----------------------------------------------------------------------
        function decodeFromPixelBuffer(pixelArr, width, height){
            let headerBits = '';
            let messageBits = '';
            let headerParsed = false;
            let messageLengthInBytes = 0;

            for(let i=0; i < pixelArr.length; i += 8){
                const p1_idx = i;
                const p2_idx = i + 4;
                if(p2_idx >= pixelArr.length) break;

                const diff = Math.abs(pixelArr[p2_idx] - pixelArr[p1_idx]);
                const range = getPVDRange(diff);
                
                if(range){
                    const t = range.t;
                    const b = diff - range.L;
                    const currentBits = b.toString(2).padStart(t, '0');
                    let remainingBits = currentBits;

                    if (!headerParsed) {
                        const neededForHeader = HEADER_SIZE_BITS - headerBits.length;
                        const bitsToTake = Math.min(remainingBits.length, neededForHeader);
                        headerBits += remainingBits.substring(0, bitsToTake);
                        remainingBits = remainingBits.substring(bitsToTake);

                        if (headerBits.length === HEADER_SIZE_BITS) {
                            for(let j=0; j<32; j+=8){
                                messageLengthInBytes = (messageLengthInBytes << 8) | parseInt(headerBits.substring(j, j+8), 2);
                            }
                            headerParsed = true;
                        }
                    }
                    
                    if (headerParsed) {
                        const totalMsgBitsNeeded = messageLengthInBytes * 8;
                        const neededForMessage = totalMsgBitsNeeded - messageBits.length;
                        const bitsToTake = Math.min(remainingBits.length, neededForMessage);
                        messageBits += remainingBits.substring(0, bitsToTake);
                        
                        if (messageBits.length >= totalMsgBitsNeeded) {
                            return {ok: true, message: bytesToText(bitsToBytes(messageBits))};
                        }
                    }
                }
            }
            // Final Error Checks (simplified for brevity)
            if (!headerParsed) { return {ok:false, reason:`Not enough image capacity for header.`}; }
            const expectedBits = messageLengthInBytes * 8;
            if (messageBits.length < expectedBits) { return {ok:false, message: bytesToText(bitsToBytes(messageBits)), reason:`Message truncated. Expected ${expectedBits} bits.`}; }
            return {ok: false, reason: 'Failed to read message data.'};
        }

        binIn.addEventListener('change', e=>{
            const f = e.target.files[0]; if(!f) return;
            const r = new FileReader();
            r.onload = ev => {
                const arr = new Uint8Array(ev.target.result);
                const dv = new DataView(arr.buffer);
                const [w, h] = [dv.getUint32(0, true), dv.getUint32(4, true)];
                const pixelBytes = arr.slice(8);
                const res = decodeFromPixelBuffer(pixelBytes, w, h);
                decodedEl.value = res.message || '';
                logMessage(`Decoded from .bin: ${res.reason || 'Success'}`);
            };
            r.readAsArrayBuffer(f);
        });

        imgIn.addEventListener('change', e=>{
            const f = e.target.files[0]; if(!f) return;
            const r = new FileReader();
            r.onload = ev => {
                const img = new Image();
                img.onload = () => {
                    canvas.width = img.width; canvas.height = img.height;
                    ctx.drawImage(img,0,0);
                    const id = ctx.getImageData(0,0,canvas.width,canvas.height);
                    const pixelBytes = id.data;
                    const res = decodeFromPixelBuffer(pixelBytes, id.width, id.height);
                    decodedEl.value = res.message || '';
                    logMessage(`Decoded from image: ${res.reason || 'Success'}`);
                };
                img.src = ev.target.result;
            };
            r.readAsDataURL(f);
        });

        decodeBtn.addEventListener('click', ()=>{
            if(binIn.files.length) binIn.dispatchEvent(new Event('change'));
            else if(imgIn.files.length) imgIn.dispatchEvent(new Event('change'));
            else alert('Upload a file first.');
        });

        // ---- BMP generator (24-bit, no alpha) ----
        function generateBMPFromRGBA(rgba, width, height){
            const rowSize = (width * 3 + 3) & ~3; 
            const pixelDataSize = rowSize * height;
            const fileSize = 14 + 40 + pixelDataSize;
            const buffer = new ArrayBuffer(fileSize);
            const dv = new DataView(buffer);
            let offset = 0;
            // BITMAPFILEHEADER (14 bytes)
            dv.setUint8(offset++, 0x42); dv.setUint8(offset++, 0x4D); 
            dv.setUint32(offset, fileSize, true); offset += 4;
            dv.setUint32(offset, 0, true); offset += 4;
            dv.setUint32(offset, 14 + 40, true); offset += 4;
            // BITMAPINFOHEADER (40 bytes)
            dv.setUint32(offset, 40, true); offset += 4; 
            dv.setInt32(offset, width, true); offset += 4;
            dv.setInt32(offset, height, true); offset += 4;
            dv.setUint16(offset, 1, true); offset += 2; 
            dv.setUint16(offset, 24, true); offset += 2;
            dv.setUint32(offset, 0, true); offset += 4; 
            dv.setUint32(offset, pixelDataSize, true); offset += 4;
            dv.setUint32(offset, 0, true); offset += 4;
            dv.setUint32(offset, 0, true); offset += 4;
            dv.setUint32(offset, 0, true); offset += 4;
            dv.setUint32(offset, 0, true); offset += 4;

            // Pixel data: BMP stores rows bottom-up (BGR)
            const pixelArray = new Uint8Array(buffer, 14 + 40);
            let pOff = 0;
            for(let row = height - 1; row >= 0; row--){
                let rowPos = row * width * 4; 
                for(let x = 0; x < width; x++){
                    const r = rgba[rowPos + x*4 + 0];
                    const g = rgba[rowPos + x*4 + 1];
                    const b = rgba[rowPos + x*4 + 2];
                    
                    pixelArray[pOff++] = b;
                    pixelArray[pOff++] = g;
                    pixelArray[pOff++] = r;
                }
                while((pOff % 4) !== 0){ pixelArray[pOff++] = 0; }
            }
            return new Blob([buffer], {type: 'image/bmp'});
        }

        // --- Theme Toggler Logic ---
        function updateThemeIcons(isDark) {
            const moon = document.getElementById('moon-icon');
            const sun = document.getElementById('sun-icon');
            if (isDark) {
                document.body.classList.remove('light-mode');
                if (moon) moon.style.display = 'block';
                if (sun) sun.style.display = 'none';
                
            } else {
                document.body.classList.add('light-mode');
                if (moon) moon.style.display = 'none';
                if (sun) sun.style.display = 'block';
            }
        }

        function toggleTheme() {
            const isCurrentlyLight = document.body.classList.contains('light-mode');
            // If it is currently light, the target is dark (true).
            const isTargetingDark = isCurrentlyLight; 
            
            localStorage.setItem('theme', isTargetingDark ? 'dark' : 'light');
            updateThemeIcons(isTargetingDark);
        }

        function loadTheme() {
            const savedTheme = localStorage.getItem('theme');
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            
            // Determine initial target: Default to system preference if no saved theme, otherwise use saved theme.
            const isDark = savedTheme ? (savedTheme === 'dark') : prefersDark;
            
            updateThemeIcons(isDark);
            
            if (toggleButton) {
                toggleButton.addEventListener('click', toggleTheme);
            }
        }
        
        // --- NEW CACHE CLEAR FUNCTION ---
        function clearCacheAndReload() {
            localStorage.removeItem('theme'); // Clear the saved theme preference
            alert('Cache (theme preference) cleared. Page will now reload.');
            window.location.reload(); // Reload the page to apply default settings
        }


        // --- UI Effects (Matrix Rain) ---
        function initMatrixRain() {
            const matrix = document.getElementById('matrix');
            for (let i = 0; i < 50; i++) {
                const bit = document.createElement('div');
                bit.className = 'data-bits';
                bit.textContent = ['0', '1'][Math.floor(Math.random() * 2)];
                bit.style.left = Math.random() * 100 + '%';
                bit.style.animationDelay = Math.random() * 2 + 's';
                matrix.appendChild(bit);
            }
        }
        document.addEventListener('DOMContentLoaded', () => {
            initMatrixRain();
            loadTheme(); 
        });
    </script>
</body>
</html>
